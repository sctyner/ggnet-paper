% !TeX root = RJwrapper.tex
\title{Network Visualizations in \pkg{ggplot2}}
\author{by Sam Tyner, Fran\c{c}ois Briatte and  Heike Hofmann}

\maketitle
\abstract{
This paper explores three different techniques to visualize networks by building on the `grammar of graphics' framework implemented in the \pkg{ggplot2} package. The goal of each technique is to provide the user with the ability to apply the flexibility of \pkg{ggplot2} to the visualization of network data, including through the mapping of network attributes to specific plot aesthetics. We will show that these additions contribute significantly to the study of networks by making visualization of networks intuitive in the \pkg{ggplot2} structure.
}

\hh{TODO list:

\begin{enumerate}
\item \hh{start of end phase!!! Proof read.
Check examples for consistency. }
\item \hh{need to re-run the timing after all the changes are made to the packages. }
%\item Should we feature curves in one of the examples?\\
%\fb{I've used curves in the \texttt{email\_ggnetwork} example.}
% \item a couple of the examples don't have all three solutions yet.\\
% \fb{Which ones please?}
% \hh{looks like we're done :)}
%\item could we keep to the convention to use \code{CRANpkg} for the first mentioning of a package on CRAN (because it includes a hyperlink to CRAN) and \code{pkg} afterwards (same with the bioconductor package we have). Abstract and title don't count as first mentioning ...\\
%\fb{Works for me.}
% \item moved the comment to the discussion section
\item \fb{Not sure why, but all figures get sent to the end in the current version of the doc.}
\hh{working on it ... and it should be much better in this version already.}
\end{enumerate}}



<<setup_knitr, echo=FALSE>>=
library(knitr)
opts_chunk$set(
  tidy = FALSE, echo = FALSE, cache = FALSE, eval = TRUE,
  message = FALSE, warning = FALSE, highlight = FALSE, background = '#FFFFFF',
  fig.height = 8, fig.width = 8, fig.align = 'center', fig.show = 'hide'
)

## From Josh O'Brien's stackoverflow answer:
## http://stackoverflow.com/questions/11030898/knitr-how-to-align-code-and-plot-side-by-side
## These two settings control text width in codefig vs. usual code blocks
partWidth <- 35
fullWidth <- 60
options(width = fullWidth)

##  (1) CHUNK HOOK FUNCTION
##   First, to set R's textual output width on a per-chunk basis, we
## need to define a hook function which temporarily resets global R's
## option() settings, just for the current chunk
knit_hooks$set(r.opts = local({
    ropts <- NA
    function(before, options, envir) {
        if (before) {
            ropts <<- options(options$r.opts)
        } else {
            options(ropts)
        }
    }
}))

## (2) OUTPUT HOOK FUNCTION

##   Define a custom output hook function. This function processes _all_
## evaluated chunks, but will return the same output as the usual one,
## UNLESS a 'codefig' argument appeared in the chunk's header.  In that
## case, wrap the usual textual output in LaTeX code placing it in a
## narrower adjustbox environment and setting the graphics that it
## produced in another box beside it.

defaultChunkHook <- environment(knit_hooks[["get"]])$defaults$chunk

codefigChunkHook <- function (x, options) {
        main <-  defaultChunkHook(x, options)
        before <-
            "\\vspace{1em}\n
             \\begin{adjustbox}{valign=t}\n
             \\begin{minipage}{.49\\textwidth}\n"
        after <-
            paste("\\vspace{1em}\n
                   \\end{minipage}\n
                  \\begin{minipage}{.49\\textwidth}\n",
                   paste0("\\includegraphics[width=\\textwidth]{figure/",
                          options[["label"]], "-1.pdf}\n
                          \\end{minipage}\n
                          \\end{adjustbox}"),
                          sep="\n")
    ## Was a codefig option supplied in chunk header?
    ## If so, wrap code block and graphical output with needed LaTeX code.
    if (!is.null(options$codefig)) {
      return(sprintf("%s %s %s", before, main, after))
    } else {
      return(main)
    }
}

knit_hooks[["set"]](chunk = codefigChunkHook)


## (3) TEMPLATE
##   codefig=TRUE is just one of several options needed for the
## side-by-side code block and a figure to come out right. Rather
## than typing out each of them in every single chunk header, we
## define a _template_ which bundles them all together. Then we can
## set all of those options simply by typing opts.label="codefig".

opts_template[["set"]](
codefig = list(codefig = TRUE, fig.show = "hide",
               r.opts = list(width = partWidth),
               tidy.opts = list(width.cutoff = partWidth)))
@


<<load_packages, results='hide'>>=
library(dplyr)
library(ggplot2) # needs to be version â‰¥ 1.0.1.9003

## ggnet2
if (!require(ggnet, quietly = TRUE)) {
  devtools::install_github("briatte/ggnet")
}
library(ggnet)

## geom_net
if (!require(geomnet, quietly = TRUE)) {
  devtools::install_github("sctyner/geomnet")
}
library(geomnet)

## ggnetwork
if (!require(ggnetwork, quietly = TRUE) ||
    packageVersion("ggnetwork") < "0.2.0") {
  devtools::install_github("briatte/ggnetwork")
}
library(ggnetwork)
@

% introductory section
\par There are many kinds of networks, and networks are extensively studied across many disciplines \citep{watts2004ars}. Social network analysis is a longstanding and prominent subfield of sociology , and the study of biological networks, such as protein-protein interaction networks or metabolic networks, is a notable subfield of biology \citep{prell2011social, junker2008analysis}. Though these two disciplines and the many others that study networks are extremely different, they all benefit from good network visualization methods.

% Visualization of networks helps with analysis
Coloring the vertices or edges in a graph is a quick way to visualize grouping and can help with pattern or cluster detection. The vertices in a network and the edges between them compose the structure of a network, and being able to discover patterns among them visually is a key part of network analysis. Viewing multiple layouts of the same network can also help reveal patterns or clusters that would not be discovered when only viewing one layout or analyzing only its underlying adjacency matrix.

% Many network packages exist, but are not easy to use
Many R packages already exist for network analysis and visualization such as \CRANpkg{igraph} by \citet{igraph}, \CRANpkg{sna} by \citet{sna}, and \CRANpkg{network} by \citet{network.jss, network}. Unfortunately, there is no standard format for network visualization across these packages, which requires detailed knowledge from users of each one of these packages in order to make meaningful changes to the network visualization. Customizing the colors, sizes, etc. of the vertices and edges of the network is done ``by hand'' and differently in each of these packages. For instance, the \pkg{igraph} package allows for coloring vertices by groups but the user has to assign the colors to each vertex individually as opposed to assigning color by a grouping factor variable.

% ggplot2 as an implementation framework
In this paper, our objective is to test the possibility to bring network plotting capabilities to the popular and widely used \CRANpkg{ggplot2} package \citep{ggplot2}. Designed as an implementation of the `grammar of graphics' proposed by \citet{wilkinson:1999}, the \pkg{ggplot2} package has become extremely popular among R users,%
  %
  \footnote{In order to give an indication of how massively large the user base of \pkg{ggplot2} is, we looked at its usage statistics from January 1, 2015 to October 10, 2015 (see \url{http://cran-logs.rstudio.com/}). Over that period, the \pkg{ggplot2} package was downloaded over 1.2 million times from CRAN, which amounts to over 4,000 downloads per day. The package has been downloaded at least once in 215 countries, and in 21 of those countries, including China, Israel, and Colombia, it has been downloaded over 10,000 times.} %
  %
  to the point that it has even inspired a port of its syntax to the Python programming language, which is a rare achievement for an R package.%
  %
  \footnote{See \url{http://ggplot.yhathq.com/}.} %
  %
%\hh{XXX side note, but do you know about the port of ggplot2 to plotly? \url{https://plot.ly/ggplot2/} }
%\fb{Nope, I had missed that one. Looks nice! Want to add it to the footnote?}
%\hh{not necessary - I have to admit that I find the use of footnotes excessive - I havent seen nearly as many footnotes in any paper in Stats - I'm assuming that that is a Poly Sci thing?}
%\fb{Oh, believe me, we're nowhere near law scholars or historians :) every social science usually goes heavy on footnotes for details, sources, remarks etc.}

  This is the audience we are aiming at by making network visualizations a part of \pkg{ggplot2}.

Because the syntax implemented in the \pkg{ggplot2} package is extendable to many different kinds of plots, many packages have built additional functionalities on top of it, including
% \fb{Perhaps we could stress that one of the benefits of learning the
%``grammar of graphics" is the opportunity to use that grammar in many
%different situations, e.g. with}
the \CRANpkg{ggmap} package by \citet{ggmap} for spatial visualization, the \CRANpkg{ggfortify} package by \citet{ggfortify} for visualizing statistical models, the package \CRANpkg{GGally} by \citet{ggally}, or the \BIOpkg{ggbio} Bioconductor package by \citet{ggbio}, which provides graphics for biological data, to name a only few. Just as these examples have increased the utility of \pkg{ggplot2}, our additions aim to extend the benefits of the grammar of graphics to network visualization. Our efforts are supported by the most recent changes to \pkg{ggplot2} (version 1.1.0, released mid November 2015), which aim at
facilitating its extension through additional geometries (or \samp{geoms}).%
  %
  % this URL should be replaced with the CRAN one when ggplot2 1.1.0 gets there
  % HH: I just replaced the URL with the CRAN one - as soon as version 1.1.0 comes out, it will point to the correct file
  \footnote{See \url{https://cran.r-project.org/web/packages/ggplot2/NEWS} for the full list of changes in \pkg{ggplot2} 1.1.0, as well as the new package vignette, ``Extending ggplot2'', which explains how the internal \code{ggproto} system of object-oriented programming can be used to create new geoms.} %
  %

In the remainder of this paper, we present three different approaches to network visualization with \pkg{ggplot2}. Section~\ref{sec:background} introduces the basic terminology of networks and illustrates their ubiquity in natural and social life. Section~\ref{sec:implementations} then discusses the logic behind each of the three approaches that we offer. Section~\ref{sec:examples} extends that discussion through several examples ranging from simple to complex networks, for which we provide the code corresponding to each approach alongside its graphical result.

\section{A quick primer to network structures}
\label{sec:background}

% getting into more of the nitty-gritty details
At its core, a network is simply a set of points connected in pairs by a set of lines \citep{newman}. Here, we refer to the lines as edges (or ties) and to the points as nodes (or vertices), and we further restrict our discussion to one-mode networks, i.e. networks where all nodes are of the same kind and are able to connect to each other.

The two sets of graphical objects that make up a network (that is, points and segments between them) have been used to encode a huge variety and quantity of information across many different fields of study. For instance, networks of scientific collaboration, a food web of marine animals, and American college football games are all covered in a paper on community detection in networks by \citet{football}. \citet{networkfailures} examine node failure in interdependent networks like power grids.  Social networks, such as links between actors found on \url{http://www.imdb.com/}, and neural networks, like the completely mapped neural network of the \textit{C. elegans} worm are also extensively studied \citep{smallworld}.

Networks vary widely in scope and complexity: the smallest network is simply an edge between two vertices, while one of the most commonly used and most complex networks, the world wide web, has billions of vertices (Web pages) and billions of edges (hyperlinks) connecting them. The edges in a network can  be directed or undirected: directed edges represent information travelling from one vertex to another, and switching the direction would change the structure of the network. The World Wide Web is an example of a directed network because hyperlinks connect one Web page to another, but not necessarily the other way around. Undirected edges are simply connections between vertices. Co-authorship networks are examples of undirected networks: nodes are authors connected by an edge if they have authored an academic publication together.


A social network is a network that everyone is a part of in one way or another. We do not necessarily refer here to social media like Facebook or LinkedIn, but rather to the connections we form with other people. To demonstrate the functionality of our tools for plotting networks, we have chosen an example of a social network from the popular television show \emph{Mad Men}. This network, which was compiled by \citet{madmen}, is made up of 52 vertices and 87 edges. Each vertex represents a character on the show, and there is an edge between every two characters who have had a romantic relationship.


\begin{figure}[hbtp]
\centering
<<madmen_geom_net, fig.width=7, fig.height=7.5>>=
# code for geom_net
# data step: merge edges and nodes
MMnet <- merge(madmen$edges, madmen$vertices,
               by.x = "Name1", by.y = "label", all = TRUE)
# create plot
ggplot(data = MMnet, aes(from_id = Name1, to_id = Name2)) +
  geom_net(aes(colour = Gender), size = 4, label = TRUE,
           vjust = -0.6, ecolour = "grey60") +
  scale_colour_manual(values = c("#FF69B4", "#0099ff")) +
  xlim(c(-0.05, 1.05)) +
  theme_net() +
  theme(legend.position = "bottom")
@
\includegraphics[width=0.6\textwidth]{figure/madmen_geom_net-1.pdf}
\caption{\label{fig.cap:madmen} Graph of the characters in the show Mad Men who are linked by a romantic relationship. }
\end{figure}
%%\afterpage{\clearpage}

Figure~\ref{fig.cap:madmen} shows this network. In the plot, we can see one central character who has many more relationships than any other character. This vertex represents the main character of the show, Don Draper, who is quite the ``ladies' man.''  This example shows just how ubiquitous networks are.



% ==============================================================================
%
\section{Three implementations of network visualizations}%
\label{sec:implementations}
%
% ==============================================================================


There are two main approaches to making use of the \pkg{ggplot2} framework: (i) implement network visualizations using \pkg{ggplot2}, by providing a wrapper for the user to visualize a network with \pkg{ggplot2} elements, and (ii) implement network visualizations as internal layers in \pkg{ggplot2}.  For the second approach, two main implementations exist: one which implements the structures of a network, such as nodes, edges, and node labels as independent geoms and another which wraps all of these structures into a single geom. We will discuss all of these approaches in this paper.


\subsection{ggnet2} % ==========================================================

The \code{ggnet2} function is an improved version of the \code{ggnet} function, which has been part of the \pkg{GGally} package since 2013 \citep{ggally}. Both functions can be separately installed in the form of a small R package available from \url{https://github.com/briatte/ggnet}, and a detailed introduction to the \code{ggnet2} function is available from within the package as a vignette.%
  %
  \footnote{The vignette can be viewed online at \url{https://briatte.github.io/ggnet/}.}%

The \code{ggnet2} function offers a large range of network visualization functionalities in a single function call. Although its result is a \pkg{ggplot2} object that can be further styled with \pkg{ggplot2} scales and themes, the syntax of the \code{ggnet2} function is designed to be easily understood by the user: the aesthetics relating to the nodes are controlled by arguments such as \code{node.alpha} or \code{node.color}, while those relating to the edges are controlled by %similarly named
arguments starting with \samp{edge}. As a consequence, while \code{ggnet2} applies the grammar of graphics to network objects, the function itself still works very much like the plotting functions of the \pkg{igraph} and \pkg{network} packages: a long series of arguments is used to control every possible aspect of how the network should be visualized.

The \code{ggnet2} function takes a single network object as input. This initial object might be an object of class \code{network} (with the exception of hypergraphs or multiplex graphs), or any data structure coercible to an object of that class, such as an incidence matrix, an adjacency matrix, or an edge list. Additionally, if the \CRANpkg{intergraph} package \citep{intergraph} is installed, the function  also accepts a network object of class \code{igraph}. Internally, the function converts the network object to two data frames, one for edges and another one for nodes, and then passes them to \pkg{ggplot2}. Each of the two data frames contain the information required by \pkg{ggplot2} to plot segments and points respectively, such as a shape for the points (nodes) and a linetype for the segments (edges). The final result returned to the user is a plot with a minimum of two layers (or more, if there are edge and/or node labels).%

The \code{mode} argument of \code{ggnet2} controls how the nodes of the network are to be positioned in the plot returned by the function. This argument can take any of the layout values supported by the \code{gplot.layout} function of the \pkg{sna} package, and defaults to \samp{fruchtermanreingold}, which places the nodes through the Fruchterman-Reingold layout algorithm \citep{fruchterman_reingold}. See \code{?sna::gplot.layout} for the many other possible layouts and their parameters, which can also be passed \code{ggnet2} through the \code{layout.par} argument.


Other arguments passed to the \code{ggnet2} function offer extensive control over the aesthetics of the plot that it returns, including %through
the addition of edge and/or node labels and their respective aesthetics.
Arguments such as \code{node.shape} or \code{edge.lty}, which  control the shape of the nodes and the linetype of the edges, respectively, can take either a global value, such as \samp{15} (for \code{node.shape}) or \samp{dashed} (for \code{edge.lty}), a vector of global values, or the name of an edge or vertex attribute, in which case the values of that attribute are used as the mapping aesthetic.

This last functionality builds on one of the strengths of the \pkg{network} class, which can store meta-information on network edges and nodes as attributes that are then accessible to the user through the \code{\%e\%} and \code{\%v\%} operators respectively.%
  %
  \footnote{See \citet[p.~22-24]{network}. The equivalent operators in the \pkg{igraph} package are called \code{E} and \code{V}.} %
  %
  Just like \code{net \%v\% "importance"} will return the vertex attribute \samp{importance} of object \code{net} if that object is of class \code{"network"} and the attribute exists, if the \code{ggnet2} function is given the \code{node.alpha = "importance"} argument, it will interpret it as an attempt to map the vertex attribute called \samp{importance} to the transparency level of the nodes. The same result can be achieved by passing the more explicit argument \code{node.alpha = net \%v\% "importance"}. This functionality aims at making the \code{ggnet2} function work in similar fashion to how \pkg{ggplot2} maps aesthetics within the \code{aes} operator.

The \code{ggnet2} function also provides a few network-specific options, such as sizing the nodes as a function of their (unweighted) degree, or using the primary and secondary modes of a bipartite network as an aesthetic mapping for the nodes.%
  %
  % added to answer Sam's comment about clarity/rephrasing
  \footnote{Bipartite (or 'two-mode') networks are networks with two different kinds of nodes and where all ties are formed between these two kinds. Affiliation networks, which represent the ties between individuals and the groups to which they belong, are examples of such networks \citep[see][p.~53-54 and p.~123-127]{newman}.}%
  %
  As a result, the function combines two different kinds of processes: (i) it translates a network object into a data frame suitable for plotting with \pkg{ggplot2}, and (ii) it applies  network-related aesthetic operations to that data frame, such as coloring the edges in function of the color of the nodes that they connect.

% \hh{XXX Francois, could you go into more detail here?
% node aesthetics, edge aesthetics, what kind of networks work as input ... is it restricted to output from the network package? e.g. the expectation from the user is really to be able to deal with a network call.
% How you work with the networks to get additional information in is also interesting - you could also discuss the edge and node operators that you use.
% The output that is produced is a ggplot2 object, which means that additional ggplot2 layers can be added on top, and themes or other scaling methods can be used.
% }

% \fb{XXX Is that summary enough, or should I delve into the parameters and aesthetics? If I do, this is going to be a long paper, there are tons of arguments.}
% \hh{XXX I know that there are a lot of arguments - they are not all similarly important, though. And there is a system ... maybe you could go into a few more parameters when you explain the system above?}
% \fb{I have added some details on the system: see the node.shape and edge.lty paragraph.}


\subsection{geomnet}

\subsubsection{Data Structure}
\hh{XXX needs a gentler intro: geomnet is a package available at YYY implementing network visualization in a single ggplot2 layer. It consists of two main functions: geom\_net and stat\_net. All of the calculation (from edge list to layout) is done in stat\_net, the rendering happens in geom\_net. }

%Visualizing networks with a single layer as done
The approach taken in \code{geomnet} is similar to the implementation of other, native \pkg{ggplot2} geoms, such as, for example, \code{geom\_smooth}. When using \code{geom\_smooth}, the user does not need to know about any of the internals of the loess function, and similarly, when using \code{geomnet}, the user is not expected to know about the internals of the layout algorithm, but only needs to specify the essential elements necessary for calculating a layout. On the other hand, if users are comfortable with network analysis, the whole apparatus of layout methods provided by the \pkg{sna} package is available to them through the parameters \code{layout} and \code{layout.par}.
%
Network analysis is usally working with two sources of information: one data set consisting of a description of the actors, represented as the vertices in the network, and another data set detailing the relationship between these actors, the edge dataset. We assume the vertices are labelled using an `id' column and \hh{XXX the next sentence is not clear yet XXX how about: Edges are described as connection between vertices via their respective `id' labels in a `from' and a `to' column.} that the edges are described by the vertices they connect via a `from' column and a `to' column whose entries are the vertex `ids'. In order for this geometry to work, these two data sets need to be combined into a single data frame. For this, we are using the convention that all of the vertex information is merged into the edge data set using the `from' as the reference column \hh{in a full join operations:}. Generally, there will be some vertices that are sinks in the network because they only show up in the `to' column. We can easily accommodate for these by adding artificial edges in the data set that have missing information for the `to' column.

Fortunately, R provides functionality that allows for an easy way of producing the required result: \code{merge} (in base R), \code{join} \citep[in \CRANpkg{plyr} see][]{plyr} and \code{full\_join} \citep[in \CRANpkg{dplyr}, see][]{dplyr} can be used. In \code{merge} the argument \code{all} needs to be set to \code{TRUE}; in \code{join}, the parameters have to be set to \code{type = "full"} and \code{all = TRUE}. These operations are equivalent to a `full join' in SQL terminology.

The formal requirements of \code{stat\_net} are two columns, called \code{from\_id} and \code{to\_id}. During this routine, columns \code{x, y} and \code{xend, yend} are calculated and used as a required input for \code{geom\_net}.
%
Other variables may also be included for each edge, such as the edge weight, in-degree, out-degree or grouping variable.

\subsubsection{Parameters and aesthetics}

Parameters that are currently implemented in \code{geom\_net} are:

\begin{itemize}
\item {\bf layout:}
the \code{layout} parameter takes a character value corresponding to the possible layouts in the \pkg{sna} package that are available within the \code{gplot.layout.*()} family of functions.  The default layout is the Kamada-Kawai layout, a force-directed layout for undirected networks \citep{kamadakawai}.
% removed a sentence here to include it above in description of ggnet2
% sorry for blatant act of sentence piracy!
Corresponding to each layout, the parameter  \code{layout.par} consists of a list of the parameters for the chosen layout. \code{fiteach} is a logical value specifying whether each panel's data should be fit separately (default) or whether the same layout should be used for all of the panels.
\item {\bf nodes/vertices:} any of \pkg{ggplot2}'s aesthetics relating to points, i.e.\ aesthetics such as colour, size, shape, and alpha are available and used for specifying the appearance of nodes in the network.
%
\item {\bf edges:} for edges we distinguish between two different sets of aesthetics: aesthetics that only relate to line attributes, such as  linewidth, linetype, and stroke.  These can be used in the regular way.  Additionally, node aesthetics such as alpha or colour are used for vertices unless separately spcified by using the parameters \code{ecolour} or \code{ealpha}, which are only applied to the edges.
\hh{If the \code{group} variable is specified, a new variable, called \code{samegroup} is added during the layout process. This variable is \code{TRUE}, if an edge is between two vertices of the same group, and \code{FALSE} otherwise. If \code{samegroup} is \code{TRUE}, the corresponding edge will be colored using the same color as the vertices it connects. If the edge is between vertices of a different group, a default grey shade is used for the edge. }

The parameter \code{curvature} is set to zero by default, but if specified, leads to curved edges using the newly implemented \pkg{ggplot2} geom \code{geom\_curve} instead of the regular \code{geom\_segment}.
Note that the edge specific aesthetics that overwrite node aesthetics are currently considered as `as.is' values: they do not get a legend and are not scaled within the ggplot2 framework. This is done to avoid any clashes between node and edge scales.
%
\item {\bf arrow:} whenever the parameter \code{directed} is set from its default state to \code{TRUE}, arrows are drawn from the `from' to the `to' node, with tips pointing towards the `to' node.  By default, arrows have an absolute size of 10 points. The parameter \code{arrowsize} consists of a positive numeric value that is used as a multiple of the original arrow size, i.e.\ \code{arrowsize = 2} shows arrow tips at twice their original size. In order to avoid overplotting of the arrow tips by the nodes, the parameter \code{arrowgap} can be used. \code{arrowgap} specifies a proportion by which the edge should be shrunk with default of 0.05. A value of 0.5 will result in edges drawn only half way from the `from' node to the `to' node.
\item {\bf labels:}  \code{label} can be used as either a logical parameter or as a data variable, in which case it is assumed that the associated variable consists of the character strings to be used for labeling the nodes. Again, if \code{colour} is specified for the nodes, the same values are used for the labels, unless \code{ labelcolour} is specified. Other parameter values, such as \code{vjust} and \code{hjust} help in adjusting labels relative to the nodes. The parameters work in the same fashion as in native \pkg{ggplot2} geoms.
\end{itemize}

\subsection{ggnetwork}

\pkg{ggnetwork} is a small R package that mimicks the behaviour of \code{geomnet} by defining several geoms to achieve similar results. The package can be installed from \url{https://github.com/briatte/ggnetwork} and is fully documented in the package vignette.%
  %
  \footnote{The vignette can be viewed online at \url{https://briatte.github.io/ggnetwork/}.}%

The approach taken by the \pkg{ggnetwork} package is to alias some of the native geoms of the \pkg{ggplot2} package, an aliased geom being a variant of an already existing one. The \pkg{ggplot2} package contains several examples of aliased geoms, such as \code{geom\_histogram}, which is a variant of \code{geom\_bar} see \citep[see][p.~67, Table~4.6]{ggplot2}.

Following that logic, the \pkg{ggnetwork} package adds four aliased geometries to \pkg{ggplot2}:

\begin{itemize}
  \item \code{geom\_nodes}, an alias to \code{geom\_point};
  \item \code{geom\_edges}, an alias to either \code{geom\_segment} or \code{geom\_curve};
  \item \code{geom\_nodetext}, an alias to \code{geom\_text}; and
  \item \code{geom\_edgetext}, an alias to \code{geom\_label}.
\end{itemize}

The four geoms are used to plot nodes, edges, node labels and edge labels, respectively. Two of the geoms that they alias, \code{geom\_curve} and \code{geom\_label}, are part of the new geometries introduced in \pkg{ggplot2} version 1.1.0. All four geoms behave exactly like those that they alias, and take exactly the same arguments. The only exception to that rule is the special case of \code{geom\_edges}, which accepts both the arguments of \code{geom\_segment} and those of \code{geom\_curve}; if its \code{curvature} argument is set to anything but \code{0} (the default), then \code{geom\_edges} behaves exactly like \code{geom\_curve}; otherwise, it behaves exactly like \code{geom\_segment}.

Just like the \code{ggnet2} function, the \pkg{ggnetwork} package takes a single network object as input, which might again be an object of class \code{"network"} or some data structure coercible to that class, or an object of class \code{"igraph"} when the \pkg{intergraph} package is installed. This object is passed to the \code{data} argument of the \code{ggplot} function after being converted to a data frame by the `workhorse' function of the \pkg{ggnetwork} package, which is also called \code{ggnetwork}.

Internally the \code{ggnetwork} function starts by computing the \code{x} and \code{y} coordinates of all nodes in the network with respect to its \code{layout} argument, which defaults to the Fruchterman-Reingold layout algorithm \citep{fruchterman_reingold}. It then extracts the edge list of the network, to which it adds the coordinates of the sender and receiver nodes as well as all edge-level attributes. The result is a data frame with as many rows as there are edges in the network, and where the \code{x}, \code{y}, \code{xend} and \code{yend} hold the coordinates of the network edges.

At that stage, the \code{ggnetwork} function performs a left-join of that `augmented' edge list with the vertex-level attributes of the sender nodes, and further adds one self-loop per node, in order to ensure that every node is plotted even when their degree is zero---that is, even if the node is not connected to any other node of the network, and is therefore absent from the edge list. The data frame created by this process contains one row per edge as well as one additional row per node, and features all edge-level and vertex-level attributes initially present in the network.%
  %
  \footnote{One limitation of this process is that it requires some reserved variable names (\code{x}, \code{y}, \code{xend} and \code{yend}), which should not also be present as edge-level or vertex-level attributes (otherwise the function will simply break). Similarly, if an edge attribute and a vertex attribute have the same name, like  \samp{na}, which the \pkg{network} package defines as an attribute for both edges and vertices in order to flag missing data, \code{ggnetwork} will rename them to \samp{na.x} (for the edge-level attribute) and \samp{na.y} (for the vertex-level attribute).} %

The \code{ggnetwork} function also accepts the arguments \code{arrow.gap} and \code{by}. \code{arrow.gap} slightly shortens the edges of directed networks in order to avoid overplotting edge arrows and nodes, whereas the argument \code{by} is meant for use with plot facets. Passing an edge attribute to the \code{by} argument will cause \code{ggnetwork} to return a data frame in which each node appears as many times as there are unique values to the edge attribute passed to \code{by}, using the same coordinates for all occurrences. If that same edge attribute is also passed to either \code{facet\_wrap} or \code{facet\_grid}, then each edge of the network will show in only one facet of the plot, while all nodes will appear in all facets at the same position, thus making the facets of the plot comparable to each other, and allowing the user to visualize edge formation as a function of a specific edge attribute (generally some kind of temporal attribute).

Both the \code{arrow.gap} and the \code{by} arguments are further illustrated in the remainder of this paper.

% ==============================================================================
%
\section{Examples}%
\label{sec:examples}
%
% ==============================================================================

In this section, we demonstrate the current capabilities of \code{ggnet2}, \code{geomnet} and \code{ggnetwork} in a series of side by side examples. While the output is similar for each method of network visualization, the code and implementations differ across the three methods.
For each of these examples, we are going to present the code necessary to produce the network, and discuss each application in detail.

\subsection{Blood donation}
In this directed network, there are eight vertices and 27 edges.  The vertices represent the eight different blood types in humans that are most important for donation: the ABO blood types A, B, AB, and O, combined with the RhD positive (+) and negative (-) types. The edges are directed: a person whose blood type is that of a \emph{from} vertex can to donate blood to a person whose blood type is that of a corresponding \emph{to} vertex.  This network is shown in Figure~\ref{fig.cap:blood}. The code to produce each one of the networks is shown below:

% \begin{figure}[hbtp]
% \caption{\label{tab:blood}Code for the three different approaches showing the blood donation network of figure~\ref{fig.cap:blood}.}
%
<<blood_common>>=
data(blood, package = "geomnet")
@
%
<<blood_ggnet2,  echo=TRUE, fig.width=6, fig.height=6>>=
# plot with ggnet2
ggnet2(network(blood$edges[, 1:2]), mode = "circle", size = 15,
       label = TRUE, arrow.size = 10, arrow.gap = 0.05, vjust = 0.5,
       node.color = "darkred", label.color = "grey80")
@

<<blood_geom_net, echo=TRUE, fig.width=6, fig.height=6>>=
# plot with geomnet
ggplot(data = blood$edges, aes(from_id = from, to_id = to)) +
  geom_net(colour = "darkred", layout = "circle", label = TRUE, size = 15,
           directed = TRUE, vjust = 0.5, labelcolour = "grey80",
           arrowsize = 1.5, linewidth = 0.5, arrowgap = 0.05,
           selfies = TRUE, ecolour = "grey40") +
  theme_net()
@

<<blood_ggnetwork, echo=TRUE, fig.width=6, fig.height=6>>=
# plot with ggnetwork
ggplot(ggnetwork(network(blood$edges[, 1:2]),
                 layout = "circle", arrow.gap = 0.05),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(color = "grey50",
             arrow = arrow(length = unit(10, "pt"), type = "closed")) +
  geom_nodes(size = 15, color = "darkred") +
  geom_nodetext(aes(label = vertex.names), color = "grey80") +
  theme_blank()
@

In this example every vertex has a self-reference, as blood between two people of matching ABO and RhD type can always be exchanged.  The \pkg{geomnet} approach shows these self-references as circles looping back to the vertex (this is controlled by using the parameter setting \code{selfies = TRUE}).


\begin{figure}[hbt]
\begin{subfigure}[t]{.32\textwidth}
\caption{ggnet2}
\includegraphics[width=\textwidth]{figure/blood_ggnet2-1.pdf}
\end{subfigure}
\begin{subfigure}[t]{.32\textwidth}
\caption{geomnet}
\includegraphics[width=\textwidth]{figure/blood_geom_net-1.pdf}
\end{subfigure}
\begin{subfigure}[t]{.32\textwidth}
\caption{ggnetwork}
\includegraphics[width=\textwidth]{figure/blood_ggnetwork-1.pdf}
\end{subfigure}
\caption{\label{fig.cap:blood} Network of blood donation possibilities in humans by ABO and RhD blood types.}
\end{figure}
%%\afterpage{\clearpage}

\code{Colour} and \code{size} aesthetics in Figure~\ref{fig.cap:blood} are set to identity values to change the size and color of all vertices. We have also used the \code{layout} and \code{label} arguments to change the default layout to a circle layout and to print the blood types, respectively. The circle layout places blood types of the same ABO type next to each other and spreads the vertices out far enough to distinguish between the various ``in" and ``out" types.  We can tell clearly from this plot that the O- type is the universal donor: it has an out-degree of seven and an in-degree of zero. Additionally, we can see that the AB+ type is the universal recipient, with an in-degree of seven and an out-degree of zero. Anyone looking at this plot can quickly determine which type(s) of blood they can receive and which type(s) can receive their blood.

\subsection{Email network}

\begin{figure}[hbt]
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2}
<<email_ggnet2, size="footnotesize", opts.label="codefig", echo=TRUE, out.width='\\textwidth'>>=
em.cet <- as.character(
  email$nodes$CurrentEmploymentType)
names(em.cet) = email$nodes$label

edges <- subset(email$edges, nrecipients < 54)
em.net <- edges[, c("From", "to") ]
em.net <- network(em.net)
em.net %v% "curr_empl_type" <-
  em.cet[ network.vertex.names(em.net) ]

ggnet2(em.net, color = "curr_empl_type",
       size = 4, palette = "Set1",
       arrow.size = 5, arrow.gap = 0.02,
       edge.alpha = 0.25,
       edge.color = c("color", "grey50"),
       color.legend = "Employment Type") +
  theme(legend.position = "bottom")
@

\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{geomnet}
<<email_geom_net, size="footnotesize", opts.label="codefig", echo=TRUE, out.width='\\textwidth'>>=
emailnet <- merge(
  subset(email$edges, nrecipients < 54),
  email$nodes,
  by.x="From", by.y="label", all=TRUE)

ggplot(data = emailnet,
       aes(from_id = From, to_id = to)) +
  geom_net(
    aes(colour = CurrentEmploymentType,
        group = CurrentEmploymentType,
        linewidth = 3*(...samegroup../8+.125)),
    ealpha = 0.25,
    size = 4, curvature = 0.05,
    directed = TRUE, arrowsize = 0.5) +
  scale_colour_brewer("Employment Type", palette = "Set1") +
  theme_net() +
  theme(legend.position = "bottom")
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{ggnetwork}
<<email_ggnetwork, size="footnotesize", opts.label="codefig", echo=TRUE, out.width='\\textwidth'>>=
ggplot(ggnetwork(em.net, arrow.gap = 0.02),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(
    aes(color = curr_empl_type),
    alpha = 0.25,
    arrow = arrow(length = unit(5, "pt"),
                  type = "closed"),
    curvature = 0.05) +
  geom_nodes(aes(color = curr_empl_type),
             size = 4) +
  scale_color_brewer("Employment Type",
                     palette = "Set1") +
  theme_blank() +
  theme(legend.position = "bottom")
@
\end{subfigure}

\caption{\label{fig.cap:email} Email network within a company over a two week period.}
\end{figure}
\afterpage{\clearpage}

The email network comes from the 2014 VAST Challenge \citep{emailnet}. It is a directed network of emails between company employees with 55 vertices and 9,063 edges. Each vertex represents an employee of the company, and each edge stands for an email sent from one employee to one or more other employees. The arrow of the directed edge points to the recipient(s) of the email. The network contains two business weeks of emails across the entire company. In order to better visualize the structure of the communication network between employees, emails that were sent out to all employees are removed.

% let's have all of the interpretation in a single place to simplify the flow
This network is plotted in Figure~\ref{fig.cap:email}. There are six distinct clusters in this network which almost perfectly correspond to the six different types of employees in this company: administration, engineering, executive, facilities, information technology, and security.

%% HH: this is not necessarily true anymore, when taking the number of emails exchanged into account
It is interesting to observe that, in all of the layouts, the `Security' employee group plays a central role in the email network of the company. This observation holds regardless of the actual network layout used (remember that \code{ggnet2} and \code{ggnetwork} default to the Fruchterman-Reingold algorithm, while \code{geomnet} defaults to the Kamada-Kawai algorithm; both layouts are force-directed, but proceed differently to assign coordinates to the nodes).
We also see that one of the executives only communicates with a single person in Facilities, while one of the IT employees frequently communicates with a Security employee.

A comparison of the results of \pkg{ggnet}, \pkg{geomnet} and \pkg{ggnetwork} reveals some of the (subtle) differences that exist between the implementations:

\begin{itemize}

  \item %
  In the \code{ggnet2} implementation, the \sct{opacity} and thickness of the edges between employees in the same cluster are more pronounced than those of the edges between employees in different clusters. This is due to the fact that the email network does not feature edge weights: instead, every email between two employees is represented by a different edge, resulting in edge overplotting. As the \code{edge.alpha} argument has been set to a value smaller than one, multiple emails between two employees create more opaque, thicker \hh{XXX why thicker? the linewidth is not related to thickness XXX} edges between them. This effect is not visible in the layouts created by \pkg{geomnet} and \code{ggnetwork} because both implementations draw a single segment for each directed edge, regardless of how many of these edges exist in the network data.

  %The value is set to 0.25 in this example, so that four or more emails between two employees result in a completely opaque edge. %% <- is that how overplotting alpha values work?

  \item %
  In the first two layouts of Figure~\ref{fig.cap:email}, edges between employees who share the same employment type are given the color of that employment type, while edges between employees belonging to different types are plotted in grey. This feature is particularly useful to visualize the amount of within-group connectedness in a network. By contrast, in the last layout, edges are colored according to the sender's employment type, because the \code{ggnetwork} package does not support coloring edges as a function of node-level attributes.

	\item %
	  Finally, in the last two layouts of Figure~\ref{fig.cap:email}, the \code{curvature} argument has been set to 0.05, resulting in slightly curved edges in both plots. This feature, which takes advantage of the \code{geom\_curve} geometry released in \pkg{ggplot2} 1.1.0, makes it possible to visualize which edges correspond to reciprocal connections; in an email communication network, as one might expect, most edges fall into that category.

\end{itemize}



% \fb{Note that we are fitting node placement algorithms that support edge weights (at least for K-K, and at least in their \pkg{igraph} implementations) to a network that should be weighted, but that is not.}
%
% \hh{XXX Francois, what are you trying to say with the previous comment? What edge weights do you think should be used? The number of emails between sender and receiver is considered in the layout calculation in stat\_net. It is only afterwards, that the data is reduced to unique edges between from and to. }
%
 \fb{Sorry for not being clear above, I'll try again. The email network should be weighted, but it is not: instead, some of its edges are duplicated. This structure probably affects the result of the K-K placement algorithm in a way that is different from how weights should affect the result of the algorithm, which understands weights as ``geometric distances'' (K-K paper, p. 14). The same problem likely affects the F-R algorithm (which has a `weights' argument in \pkg{igraph}), although I could not understand from the paper how the edge weights are supposed to be taken into account.}
%

\hh{OK, point taken - and actually fixed. I was under the impression that the edgelist routine in the network package dealt with multiplicities in a smarter way. Thank you - see point 1 in the intro :)}

\fb{To be honest, I have no idea how \pkg{network} deals with edge multiplicity. It does not seem to deal with them at all. As for \pkg{sna}, it clearly understands edge weights when coercing to an edge list (which is the first step of its K-K layout implementation), but what happens to the weights later on is unclear to me.

Here's proof that \pkg{sna} preserves edge weights:

\code{sna::as.edgelist.sna(rbind(1:3, 1:3, 1:3))}

What happens to the weights (\code{val}) column is coded in \code{sna::gplot.layout.kamadakawai} (must have to do with the \code{edge.val.as.str} and \code{layout.par\$elen} bits, but I don't get those).}

To introduce a temporal aspect
 we facet the network by day: each panel in Figure~\ref{fig:email_facet} shows email networks associated with each day of the week. The code for these visualization is below:

 \fb{Not sure what's happening with Fig. 4a, but it's now taking half of the page on my end, squashing other subfigures out of the page. I've tried to solve the issue by setting aspect.ratio to 1.}
\hh{I first noticed this problem after you included the bikes example. It looks like some scaling issue, but the aspect ratio seems to fix it!}
\fb{Scaling issue was due to fig.width and fig.height having been removed. Putting them back fixed it. Strange thing, though: with identical fig.width and fig.height, geomnet produces a smaller figure than the two others.}

\begin{figure}[hbt]
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2}\label{email:ggnet2}
\includegraphics[width=\textwidth]{figure/email_facet_ggnet2-1.pdf}
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{geomnet}
\includegraphics[width=\textwidth]{figure/email_facet_geom_net-1.pdf}
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{ggnetwork}
\includegraphics[width=\textwidth]{figure/email_facet_ggnetwork-1.pdf}
\end{subfigure}

\caption{\label{fig:email_facet} The same email network as in figure~\ref{fig.cap:email} facetted by day of the week.}
\end{figure}
\afterpage{\clearpage}
<<email_facet_ggnet2, fig.height=4, fig.width=8, echo=TRUE, out.width='\\textwidth'>>=
# ggnet2 code for the email network facetted by day as shown in fig.4a

# data preparation
em.day <- subset(email$edges, nrecipients < 54)[, c("From", "to", "day") ]
em.day <- lapply(unique(em.day$day),
                 function(x) subset(em.day, day == x)[, 1:2 ])
em.day <- lapply(em.day, network, directed = TRUE)
for (i in 1:length(em.day)) {
  em.day[[ i ]] %v% "curr_empl_type" <-
    em.cet[ network.vertex.names(em.day[[ i ]]) ]
  em.day[[ i ]] %n% "day" <- unique(email$edges$day)[ i ]
}

# plot ggnet2
g <- list(length(em.day))
for (i in 1:length(em.day)) {
  g[[ i ]] <- ggnet2(em.day[[ i ]], size = 2, color = "curr_empl_type",
                     palette = "Set1", arrow.size = 0, arrow.gap = 0.01,
                     edge.alpha = 0.1, legend.position = "none") +
    ggtitle(paste("Day", em.day[[ i ]] %n% "day")) +
    theme(panel.border = element_rect(color = "grey50", fill = NA),
          aspect.ratio = 1)
}
gridExtra::grid.arrange(grobs = g, nrow = 2)
@

<<email_facet_geom_net, fig.height=4.5, fig.width=8, echo=TRUE, out.width='\\textwidth'>>=
# geomnet code for the  email network facetted by day as shown in fig.4b

# data step: making sure that there is one entry for each person on each day
employee <- data.frame(expand.grid(label = unique(email$nodes$label),
                                   day = unique(email$edges$day)))
employee <- merge(employee, email$nodes, by = "label")
emailnet <- merge(subset(email$edges, nrecipients < 54), employee,
                  by.x = c("From", "day"), by.y = c("label", "day"),
                  all = TRUE)

# creating the plot
ggplot(data = emailnet, aes(from_id = From, to_id = to)) +
  geom_net(aes(colour = CurrentEmploymentType,
               group = CurrentEmploymentType,
               linewidth=2*(...samegroup../8+.125)),
           fiteach = TRUE, ealpha = 0.5, size = 1.5) +
  scale_colour_brewer("Employment Type", palette = "Set1") +
  theme_net() +
  facet_wrap(~ day, nrow = 2, labeller = "label_both") +
  theme(legend.position = "bottom",
        panel.border = element_rect(fill = NA, colour = "grey60"),
        plot.margin = unit(c(0,0,0,0),"mm"))
@

<<email_facet_ggnetwork, fig.height=4, fig.width=8,echo=TRUE, out.width='\\textwidth'>>=
# ggnetwork code for the  email network facetted by day as shown in fig.4c

# create the network and aesthetics
edges <- subset(email$edges, nrecipients < 54)
edges <- edges[, c("From", "to", "day") ]
em.net <- network(edges[, 1:2])
set.edge.attribute(em.net, "day", edges[, 3])
em.net %v% "curr_empl_type" <- em.cet[ network.vertex.names(em.net) ]

# create the plot
ggplot(ggnetwork(em.net, arrow.gap = 0.02, by = "day"),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(
    aes(color = curr_empl_type),
    alpha = 0.25,
    arrow = arrow(length = unit(5, "pt"),
                  type = "closed")) +
  geom_nodes(aes(color = curr_empl_type),
             size = 2) +
  scale_color_brewer("Employment Type",
                     palette = "Set1") +
  facet_wrap(~ day, nrow = 2, labeller = "label_both") +
  theme_facet(legend.position = "bottom")
@

%\sct{XXX I am not a fan of this paragraph. Again, we should appear united.}

Note that the main difference in the visualizations of Figure~\ref{fig:email_facet} stems from whether \emph{one} layout is used across all panels (as for the \code{ggnetwork} example) or whether individual layouts are fit to each of the subsets (as for the \code{ggnet2} and the \code{geomnet} examples).
In \code{geomnet} this is controlled via the argument \code{fiteach}. By default  \code{fiteach = TRUE}, but \code{fiteach = FALSE} results in all panels sharing the same layout.
%
Through the facetting it becomes obvious that there are several days where one or more of the departments does not communicate with any of the other departments. There are only two days, day 13 and day 15, without any isolated department communications.
Facetting is one of the major benefits of creating a geometry for networks in \pkg{ggplot2}.  Facetting allows us to quickly separate dense networks into smaller subnetworks for easy visual comparison and analyses.


\subsection{\pkg{ggplot2} theme elements}
This example comes from the \code{theme()} help page in the \pkg{ggplot2} documentation \citep{ggplot2}.  It is a directed network which shows the structure of the inheritance of theme options in the construction of a \pkg{ggplot2} plot. There are 53 vertices and 36 edges in this network. Each vertex represents one possible theme option. There is an arrow from one theme option to another if the element represented by the \emph{to} vertex inherits its values from the \emph{from} vertex.  For example, the \code{axis.ticks.x} option inherits its value from the \code{axis.ticks} value, which in turn inherits its value from the \code{line} option.  Thus, setting the \code{line} option to a value such as \code{element\_blank()} sets the entire inheritance tree to \code{element\_blank()}, and no lines appear anywhere on the plot background. Finally, note that the vertices without edges were incorporated into the plot by adding their labels to the edges data frame in both the  \code{from\_id} and \code{to\_id} columns. %before passing the edges data frame to \code{ggplot}.

\begin{figure}[hbtp]
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2}
<<theme_ggnet2, size="footnotesize", opts.label="codefig", echo=TRUE>>=
te.net <- network(theme_elements$edges)
te.net %v% "size" <-
  sqrt(10 * (sna::degree(te.net) + 1))

ggnet2(te.net, label = TRUE, color = "white",
       label.size = "size", layout.exp = 0.15)
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{geomnet}
<<theme_geom_net, size="footnotesize", opts.label="codefig", echo=TRUE, fig.width=7, fig.height = 7>>=
# data step: merge nodes and edges and
# introduce a degree-out variable
TEnet <- merge(
  theme_elements$edges,
  theme_elements$vertices,
  by.x = "parent", by.y = "name", all = TRUE)
TEnet <- TEnet %>%
  group_by(parent) %>%
  mutate(degree = sqrt(10 * n() + 1))

# create plot:
ggplot(data = TEnet,
       aes(from_id = parent, to_id = child)) +
  geom_net(
    aes(fontsize = degree), directed = TRUE,
    label = TRUE, vjust = -.5, size = 3,
    ecolour = "grey70", arrowsize = 0.5,
    linewidth = 0.5) +
  theme_net() +
  xlim(c(-0.05, 1.05))
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2}
<<theme_ggnetwork, size="footnotesize", opts.label="codefig", echo=TRUE>>=
ggplot(ggnetwork(te.net),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges() +
  geom_nodes(size = 12, color = "white") +
  geom_nodetext(
    aes(size = size, label = vertex.names)) +
  scale_size_continuous(range = c(4, 8)) +
  guides(size = FALSE) +
  theme_blank()
@
\end{subfigure}

\caption{\label{fig.cap:theme} Inheritance structure of \pkg{ggplot2} theme elements. This is a recreation of the graph found at \protect\url{http://docs.ggplot2.org/current/theme.html}.}
\end{figure}
\afterpage{\clearpage}

The inheritance structure is plotted in figure \ref{fig.cap:theme}.  In this plot, it is easy to quickly determine the parent and child vertices. Using this plot made creation of the \code{theme\_net} object used throughout these examples very simple. We just made set each of the major parent elements, \code{text}, \code{rect}, and \code{line} to \code{element\_blank()} and then set the aspect ratio equal to one.

\subsection{Romantic relationships in \emph{Mad Men}}
  The following code creates the network example given in Figure~\ref{fig.cap:madmen} in the introduction. We changed the vertex size and edge color for all vertices and edges, included vertex labels, and colored the vertices according to the character's gender.

<<print, ref.label="madmen_geom_net", eval=FALSE, echo=TRUE,cache=FALSE>>=
@


The code for the other two approaches follows below and the corresponding networks are shown in figure~\ref{fig:madmen-2}.

<<madmen_prepare, echo=TRUE>>=
# data step for both ggnet2 and ggnetwork
# create undirected network
mm.net <- network(madmen$edges[, 1:2], directed = FALSE)
# gender vertex attribute
rownames(madmen$vertices) <- madmen$vertices$label
mm.net %v% "gender" <- as.character(
  madmen$vertices[ network.vertex.names(mm.net), "Gender"]
)
# gender color palette
mm.col <- c("female" = "#ff69b4", "male" = "#0099ff")
@


<<madmen_ggnet2, echo=TRUE, out.width='\\textwidth', fig.width=9, fig.height=9>>=
ggnet2(mm.net, color = mm.col[ mm.net %v% "gender" ],
       label = TRUE, label.color = mm.col[ mm.net %v% "gender" ],
       size = 4, vjust = -0.6)
@

<<madmen_ggnetwork, echo=TRUE,  out.width='\\textwidth', fig.width=9, fig.height=9>>=
ggplot(data = ggnetwork(mm.net), aes(x, y, xend = xend, yend = yend)) +
  geom_edges(color = "grey50") +
  geom_nodes(aes(colour = gender), size = 4) +
  geom_nodetext(aes(colour = gender, label = vertex.names),
                size = 4, vjust = -0.6) +
  scale_colour_manual(values = mm.col) +
  xlim(c(-0.05, 1.05)) +
  theme_blank() +
  theme(legend.position = "bottom")
@

\begin{figure}[hbtp]
\begin{subfigure}[t]{.495\textwidth}
\caption{ggnet2}
\includegraphics[width=\textwidth]{figure/madmen_ggnet2-1.pdf}
\end{subfigure}
\begin{subfigure}[t]{.495\textwidth}
\caption{ggnetwork}
\includegraphics[width=\textwidth]{figure/madmen_ggnetwork-1.pdf}
\end{subfigure}

\caption{\label{fig:madmen-2} Graph of the characters in the show Mad Men who are linked by a romantic relationship, ggnet2 and ggnetwork implementation.}
\end{figure}
%\afterpage{\clearpage}

 There is another Mad Men network given in the \pkg{gcookbook} package \citep{madmen}. It is a directed network, also of romantic relationships between characters, but it additionally includes all advances made by one character that were rejected by the other.  For example, Roger Sterling made advances toward Betty Draper, but Betty refused him,  so there is a directed edge going from Roger to Betty, but not from Betty to Roger.  If the advance is reciprocated, such as between Sal Romano and the Bellhop, there are two directed edges between the two vertices.


\begin{figure}
<<madmen2_prepare, echo = TRUE>>=
# data step for ggnet2 and ggnetwork
# create directed network
mm.dir <- network(mm.directed$edges, directed = TRUE)
# gender vertex attribute
rownames(mm.directed$vertices) <- mm.directed$vertices$label
mm.dir %v% "gender" <- as.character(
  mm.directed$vertices[ network.vertex.names(mm.dir), "Gender" ]
)
@
\caption{\label{mm2:datastep} Data preparation for the directed network of the  Mad Men example in Figures~\ref{mm2:ggnet2} and~\ref{mm2:ggnetwork}.}

\end{figure}
\begin{figure}[hbtp]
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2\label{mm2:ggnet2}}
<<madmen2_ggnet2, size="footnotesize", opts.label="codefig", echo=TRUE>>=
# see fig.7 for data preparation

ggnet2(
  mm.dir, mode = "fruchtermanreingold", size = 3,
  color = mm.col[ mm.dir %v% "gender" ],
  label = TRUE,
  label.color = mm.col[ mm.dir %v% "gender" ],
  hjust = -0.1, legend.position = "bottom",
  layout.exp = 0.15, arrow.size = 7.5,
  arrow.gap = 0.02
)
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{geomnet}
<<madmen2_geom_net, size="footnotesize", opts.label="codefig", echo=TRUE>>=
MM2net <- merge(
  mm.directed$edges,
  mm.directed$vertices,
  by.x = "Name1", by.y = "label", all = TRUE)

ggplot(data = MM2net,
       aes(from_id = Name1, to_id = Name2)) +
  geom_net(
    aes(colour = Gender),  directed = TRUE,
    label = TRUE, ecolour = "grey50",
    linewidth = 0.5, size = 2.5, vjust = -.5,
    layout = "fruchtermanreingold") +
  scale_colour_manual(
    values = c("#ff69b4", "#0099ff")) +
  xlim(c(-0.1, 1.1)) +
   theme_net() +
  theme(legend.position = "bottom")
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{ggnetwork \label{mm2:ggnetwork}}
<<madmen2_ggnetwork, size="footnotesize", opts.label="codefig", echo=TRUE, dependson="madmen2_ggnet2">>=
# see fig.7 for data preparation

ggplot(
  ggnetwork(mm.dir,
            layout = "fruchtermanreingold"),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(
    color = "grey50",
    arrow = arrow(length = unit(10, "pt"),
                  type = "closed")) +
  geom_nodes(size = 3, aes(color = gender)) +
  geom_nodetext(aes(label = vertex.names,
                    color = gender),
                hjust = -0.1) +
  scale_color_manual(values = mm.col) +
  theme_blank() +
  theme(legend.position = "bottom")
@
\end{subfigure}
\caption{\label{fig.cap:madmen2} A directed network of relationships in Mad Men.}
\end{figure}
\afterpage{\clearpage}
This network is shown in figure \ref{fig.cap:madmen2}.  It is a lot more densely connected than the previous Mad Men example.  This network allows us to see much more of the drama in the show. For instance, we can see that Roger made advances towards Betty, his business partner's wife, which is much more scandalous than what appears in the first network.

\subsection{College football}
This next example comes from M.E.J. Newman's network data web page \citep{football}.  It is an undirected network consisting of all regular season college football games played between Division I schools in Fall of 2000.  There are 115 vertices and 613 edges: each vertex represents a school, and an edge represents a game played between two schools. There is an additional variable in the vertex data frame corresponding to the conference each team belongs to, and there is an additional variable in the edge data frame that is equal to one if the game occured between teams in the same conference or zero if the game occured between teams in different conferences.

The network of football games is given in figure \ref{fig.cap:football}. Here, we have changed the \code{linetype} aesthetic to correspond to games that occur between teams in the same conference or different conferences.  These lines are dotted and solid, respectively. We have also assigned a different color to each conference, and the vertices and their labels are colored according to their conference. This coloring and changing of the linetypes make the structure of the game network easier to view.  There is one conference consisting of Navy, Notre Dame, Utah State, Central Florida, and Connecticut, which is spread out, whereas most other conferences' teams are all very close to each other because they play within conference much more than they play out of conference.  At the time, these five schools were all independents and did not have a home conference.  Without the coloring capability, we would not have been able to pick out that difference as easily.
\begin{figure}[hbtp]
\begin{subfigure}[t]{\textwidth}
\caption{ggnet2}\vspace{-.5cm}
<<football_ggnet2, size="footnotesize", opts.label="codefig", echo=TRUE>>=
rownames(football$vertices) <-
  football$vertices$label

fb.net <- network(football$edges[, 1:2],
                  directed = FALSE)
set.edge.attribute(
  fb.net, "same.conf",
  football$edges$same.conf)
fb.net %v% "conf" <-
  football$vertices[
    network.vertex.names(fb.net), "value"
    ]

ggnet2(fb.net, mode = "fruchtermanreingold",
       color = "conf",  palette = "Paired",
       color.legend = "Conference",
       edge.color = c("color", "grey75"))
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{geomnet}\vspace{-.5cm}
<<football_geom_net, size="footnotesize", fig.height=10, opts.label="codefig", echo=TRUE>>=
# data step: merge vertices and edges
ftnet <- merge(
  football$edges, football$vertices,
  by.x = "from", by.y = "label", all = TRUE)

# label independent schools
ftnet$schools <- ifelse(
  ftnet$value == "Independents", ftnet$from, "")

# create data plot
ggplot(data = ftnet,
       aes(from_id = from, to_id = to)) +
  geom_net(
    aes(colour = value, group = value,
        linetype = factor(same.conf != 1),
        label = schools),
    linewidth = 0.5,
    size = 5, vjust = -0.75, alpha = 0.3,
    layout = 'fruchtermanreingold') +
  theme_net() +
  theme(legend.position = "bottom") +
  scale_colour_brewer("Conference", palette = "Paired")  +
  guides(linetype = FALSE)
@
\end{subfigure}
%
\begin{subfigure}[t]{\textwidth}
\caption{ggnetwork}\vspace{-.5cm}
%%%%%%%%%%%%%
% SCT # out of conf. games connected by dotted lines, not the other way around
<<football_ggnetwork, size="footnotesize", opts.label="codefig", echo=TRUE>>=
ggplot(
  ggnetwork(fb.net, layout = "fruchtermanreingold"),
  aes(x, y, xend = xend, yend = yend)) +
  geom_edges(
    aes(linetype = as.factor(same.conf)),
    color = "grey50") +
  geom_nodes(aes(color = conf), size = 4) +
  scale_color_brewer("Conference",
                     palette = "Paired") +
    scale_linetype_manual(values = c(2,1)) +
  guides(linetype = FALSE) +
  theme_blank()
@
\end{subfigure}
\caption{\label{fig.cap:football} The network of regular season Division I college football games in the season of fall 2000. The vertices and their labels are colored by conference.}
\end{figure}
\afterpage{\clearpage}

\subsection{Character co-appearances in \emph{Les Mis\'{e}rables}}

This next network comes from \citet{lesmis}. It is an undirected network of coappearances of characters in Victor Hugo's \emph{Les Mis\'{e}rables}.  There are 77 vertices representing each of the 77 characters in the book, and an edge connects two vertices if those two characters appear in the same chapter of the book.  There are 254 edges in this network. The edges are also weighted by the number of coappearances. The largest weighting is 31, between the characters Jean Valjean and Cosette.
This network is shown in Figures~\ref{fig.cap:lesmis:ggnet2},~\ref{fig.cap:lesmis:ggnet}, and~\ref{fig.cap:lesmis:ggnetwork}; the corresponding code is shown below. This network reveals many important character groups, as well as the main characters in the story.  The main characters are the ones with high degree, like Valjean, Cosette, and Javert.  There is an extremely wide edge connecting Valjean and Cosette, which implies that they are strongly connected; in fact, Cosette is Valjean's adopted daughter.

% \begin{figure}[hbtp]
% \caption{\label{tab:lesmis}Code for the three approaches of visualizing the relationships between characters in Les Mis\'{e}rables as shown in Figures~\ref{fig.cap:lesmis:ggnet2},~\ref{fig.cap:lesmis:ggnet}, and~\ref{fig.cap:lesmis:ggnetwork}.}
<<lesmis_ggnet2, echo=TRUE>>=
# Code for the three visualization approaches of co-appearances
# plot with ggnet2
ggnet2(lesmis$edges[, 1:2 ], mode = "fruchtermanreingold",
       color = "white", label = TRUE, label.color = "grey30",
       edge.size = lesmis$edges$degree / mean(lesmis$edges$degree),
       edge.color = "grey60",
       layout.exp = 0.25)
@

<<lesmis_geom_net, echo=TRUE, fig.width=9.5>>=
# plot with geom_net
# data step: merge vertices and edges
lesmisnet <- merge(lesmis$edges, lesmis$vertices, by.x = "from",
                   by.y = "label", all = TRUE)
lesmisnet$degree[ is.na(lesmisnet$degree) ] <- 0

# create plot
ggplot(data = lesmisnet, aes(from_id = from, to_id = to,
                             linewidth = degree / 5 + 0.1 )) +
  geom_net(aes(size = degree, alpha = degree),
           colour = "grey30", ecolour = "grey60",
           layout = "fruchtermanreingold", label = TRUE, vjust = -0.75) +
  scale_alpha(range = c(0.3, 1)) +
  theme_net()
@

%% not sure I understand the aesth. mapping used above, so not using alpha below
<<lesmis_ggnetwork, echo=TRUE, fig.width=9.5>>=
# plot with ggnetwork
ggplot(data = ggnetwork(lesmis$edges[, 1:2 ], arrow.gap = 0),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(size = lesmis$edges$degree / mean(lesmis$edges$degree),
             color = "grey60") +
  geom_nodes(color = "white", size = 6) +
  geom_nodetext(aes(label = vertex.names), color = "grey30") +
  theme_blank()
@
%\end{figure}
%
\begin{figure}[hbtp]
\includegraphics[width=\textwidth]{figure/lesmis_ggnet2-1.pdf}
\caption{\label{fig.cap:lesmis:ggnet2} Co-appearance network of characters in Victor Hugo's \emph{Les Mis\'{e}rables} using ggnet2.}
\end{figure}
%
\begin{figure}[hbtp]
\includegraphics[width=\textwidth]{figure/lesmis_geom_net-1.pdf}
\caption{\label{fig.cap:lesmis:ggnet} Co-appearance network of characters in Victor Hugo's \emph{Les Mis\'{e}rables} using geomnet.}
\end{figure}
%
\begin{figure}[hbtp]
\includegraphics[width=\textwidth]{figure/lesmis_ggnetwork-1.pdf}
\caption{\label{fig.cap:lesmis:ggnetwork} Co-appearance network of characters in Victor Hugo's \emph{Les Mis\'{e}rables} using ggnetwork.}
\end{figure}
%
%\afterpage{\clearpage}

\subsection{Bikesharing in Washington D.C.}

The data shows the second quartal trips in 2015 taken with bikes from the bike share company \url{https://secure.capitalbikeshare.com/}.

While this bikesharing company is located in the heart of Washington D.C.\ they do have a set of bike stations just outside of Washington in Rockville, MD and north of it. Each station is shown as a dot, lines between stations indicate that at least five trips were taken between these two stations; the wider the line, the more trips have been taken between stations. In order to reflect distance between stations, we use as an additional restriction that the fastest trip was at most ten minutes long.

<<bikes_geom_net, echo=TRUE, warning=FALSE, fig.keep='all'>>=
tripnet <- merge(bikes$trips, bikes$stations, by.x = "Start.station",
                 by.y = "name", all = TRUE)

tripnet$Metro = FALSE
idx <- grep("Metro", tripnet$Start.station)
tripnet$Metro[idx] <- TRUE

ggplot(aes(from_id = Start.station, to_id = End.station), data = tripnet) +
  geom_net(aes(linewidth = n / 15, colour = Metro),
           label = TRUE, vjust = -0.5) +
  theme_net() +
  xlim(c(-0.1, 1.1)) +
  scale_colour_manual("Metro Station", values = c("grey40", "darkorange")) +
  theme(legend.position = "bottom")

data(metro_map)

ggplot(data = metro_map_df_t2, aes(x = long, y = lat)) +
  geom_raster(fill = metro_map_df_t2$color, alpha = 0.75) +
  geom_net(data = tripnet, layout = NULL, label = TRUE,
           vjust = -0.5,
           aes(from_id = Start.station,
               to_id = End.station,
               x = long, y = lat,
               linewidth = n / 15,
               colour = Metro)) +
  theme_net() +
  scale_colour_manual("Metro Station", values = c("grey40", "darkorange")) +
  theme(legend.position = "bottom")

# compare to https://secure.capitalbikeshare.com/map/
@

<<bikes_prepare, echo = TRUE>>=
bikes.net <- network(bikes$trips[, 1:2 ], directed = FALSE)
set.edge.attribute(bikes.net, "n", bikes$trips[, 3 ] / 15)
bikes.net %v% "station" <-
  grepl("Metro", network.vertex.names(bikes.net))
bikes.net %v% "station" <-
  1 + as.integer(bikes.net %v% "station")
rownames(bikes$stations) <- bikes$stations$name
bikes.net %v% "lon" <-
  bikes$stations[ network.vertex.names(bikes.net), "long" ]
bikes.net %v% "lat" <-
  bikes$stations[ network.vertex.names(bikes.net), "lat" ]
bikes.col <- c("grey40", "darkorange")
@

<<bikes_ggnet2, echo = TRUE, fig.keep='all'>>=
# Fruchterman-Reingold placement
ggnet2(bikes.net, size = 4, label = TRUE, vjust = -0.5,
       edge.size = "n", color = bikes.col[ bikes.net %v% "station" ],
       label.color = bikes.col[ bikes.net %v% "station" ],
       layout.exp = 1.1)
# geographic placement
ggnet2(bikes.net, size = 4, label = TRUE, vjust = -0.5,
       mode = c("lon", "lat"),
       edge.size = "n",
       color = bikes.col[ bikes.net %v% "station" ],
       label.color = bikes.col[ bikes.net %v% "station" ],
       layout.exp = 1.1)
@

<<bikes_ggnetwork, echo = TRUE, fig.keep='all'>>=
# Fruchterman-Reingold placement
ggplot(data = ggnetwork(bikes.net),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(aes(size = n), color = "grey40") +
  geom_nodes(aes(color = factor(station)), size = 4) +
  geom_nodetext(aes(label = vertex.names, color = factor(station)),
                vjust = -0.5) +
  scale_size_continuous("Trips", breaks = c(2, 4, 6), labels = c(30, 60, 90)) +
  scale_colour_manual("Metro station", labels = c("FALSE", "TRUE"),
                      values = c("grey40", "darkorange")) +
  theme_blank() +
  theme(legend.position = "bottom", legend.box = "horizontal")

# geographic placement
coords <- c(bikes.net %v% "lon", bikes.net %v% "lat")
coords <- matrix(coords, ncol = 2)
ggplot(data = ggnetwork(bikes.net, layout = coords),
       aes(x, y, xend = xend, yend = yend)) +
  geom_raster(data = metro_map_df_t2,
              aes(x = long, y = lat, xend = NULL, yend = NULL),
              fill = metro_map_df_t2$color, alpha = 0.75) +
  geom_edges(aes(size = n), color = "grey40") +
  geom_nodes(aes(color = factor(station)), size = 4) +
  geom_nodetext(aes(label = vertex.names, color = factor(station)),
                vjust = -0.5) +
  scale_size_continuous("Trips", breaks = c(2, 4, 6), labels = c(30, 60, 90)) +
  scale_colour_manual("Metro station", labels = c("FALSE", "TRUE"),
                      values = c("grey40", "darkorange")) +
  scale_x_continuous(limits = c(-0.1, 1.1)) +
  theme_blank() +
  theme(legend.position = "bottom", legend.box = "horizontal")
@

\begin{figure}[hbtp]
\centering
\includegraphics[width=.49\textwidth]{figure/bikes_geom_net-1.pdf}
\includegraphics[width=.49\textwidth]{figure/bikes_geom_net-2.pdf}
\caption{\label{fig:bikes} Network of bike trips using a Kamada-Kawai layout (left) and a geographically true representation (right) overlaid on a satellite map. Metro stations are shown in orange. In the Kamada-Kawai layout based on the trips taken, metro stations take a much more central position than in the geographically true representation. }
\end{figure}
%\afterpage{\clearpage}

\begin{figure}[hbtp]
\centering
\includegraphics[width=.49\textwidth]{figure/bikes_ggnet2-1.pdf}
\includegraphics[width=.49\textwidth]{figure/bikes_ggnet2-2.pdf}
\caption{\label{fig:bikes_ggnet2} ggnet2}
\end{figure}

\begin{figure}[hbtp]
\centering
\includegraphics[width=.49\textwidth]{figure/bikes_ggnet2-1.pdf}
\includegraphics[width=.49\textwidth]{figure/bikes_ggnet2-2.pdf}
\caption{\label{fig:bikes_ggnetwork} ggnetwork \fb{Problem: standardizing the coordinates to (0,1) distorts the aspect ratio} \hh{have a look at the map - the area covered is actually fairly quadratic. Geographic Lat and Long don't operate on the same scales. } \fb{Still unsure what changes I should bring to make the geographic plot as correct as possible... XYZ} }
\end{figure}

\subsection{Protein interactions in yeast}
% \fb{
%
% Should we stress the speed gain of using ggplot2 versus plot.network for instance? Below is the code to plot the same network with the network package: it takes around 4 seconds to draw. The same plot with ggnet2 takes (much) less than one second.
%
% \code{xy = gplot.layout.random(network(protein\$edges[, 1:2]), layout.par = list(dist = "uniang"))}\\
% \code{system.time(plot(network(protein\$edges[, 1:2]), coord = xy))}
%
% }
%
% \hh{XXX I like that idea! We would need to include the time for  the layout for a fair comparison though ...}

\fb{What could be a cool benchmark would be to generate random graphs of varying sizes, and then measure their plotting runtime with all functions + plot.network. I'm pretty sure the speed gain will grow faster than the size of the networks.}
\hh{I like the idea! }

This example of a protein interaction network comes from \citet{protein}. It is the complete protein-protein interaction network in the yeast species \emph{S. cerevisiae}. There are 1,870 proteins that make up the vertices of this network, with a total of 2,240 edges between them.  These edges represent ``direct physical interactions" between any two proteins \citep[][p. 42]{protein}. These interactions and their associated proteins are plotted  in Figure~\ref{fig.cap:yeast}.  We also demonstrate the layout capabilities by changing the layout to random and setting the distribution to \code{"uniang"}, which is a  ``gaussian donut" layout.  Indeed, we see a nearly round area in the middle of the graph where the layout parameter has forced there to be no vertices. Because all of the appraoches result in very similar figures, only one network is shown. The code for all three approaches is shown below:

<<yeast_ggnet2, echo=TRUE, eval = FALSE, cache=FALSE>>=
# plot with ggnet2
ggnet2(network(protein$edges[,1:2]), size = 2, color = "magenta",
      mode = "random", layout.par = list(dist = "uniang"),
      edge.alpha = 0.05)
@

<<yeast_geom_net, echo=TRUE, cache=FALSE>>=
# plot with geom_net
ggplot(data = protein$edges, aes(from_id = from, to_id = to)) +
  geom_net(alpha = 0.25, ealpha = 0.05, size = 2, colour = "magenta",
           ecolour = "grey70", linewidth = 0.5,
           layout = "random", layout.par = list(dist = "uniang")) +
  theme_net()
@

<<yeast_ggnetwork, echo=TRUE, eval = FALSE,  cache=FALSE>>=
# plot with ggnetwork
ggplot(ggnetwork(protein$edges[, 1:2], layout = "random", dist = "uniang"),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(color = "grey70", lwd = 0.5, alpha = 0.05) +
  geom_nodes(alpha = 0.25, color = "magenta", size = 2) +
  theme_blank()

@

\begin{figure}[hbtp]
\includegraphics[width=\textwidth]{figure/yeast_geom_net-1.pdf}
%\end{subfigure}
\caption{\label{fig.cap:yeast} Protein-protein interaction network in \emph{S. cerevisiae}. The layout is random.}
\end{figure}
%\afterpage{\clearpage}


\hh{Additionally, the \pkg{ggplot2} framework provides us with a considerable speed-up compared to the standard plotting routines that come with the \pkg{network} package. We executed the following code: }
<<network-plot, echo=TRUE, eval = FALSE>>=
xy = gplot.layout.random(network(protein$edges[, 1:2]),
                         layout.par = list(dist = "uniang"))
plot(network(protein$edges[, 1:2]), coord = xy)
@
\hh{100 times and compared its run time to 100 runs each of the three visualisation approaches introduced in this paper. The results are shown in Figure~\ref{fig:timings}. The \pkg{ggplot2} framework provides a two to three-fold increase in speed on average.
}
\begin{figure}
\centering
<<compare, echo = FALSE, eval = TRUE, fig.height = 4, fig.width = 8, out.width = '\\textwidth'>>=
if (!file.exists("data/timings.csv")) {
network <- data.frame(t(replicate(100, {
system.time({
#  xy = gplot.layout.random(network(protein$edges[, 1:2]),
#                         layout.par = list(dist = "uniang"))
  plot(network(protein$edges[, 1:2]), coord = gplot.layout.random(network(protein$edges[, 1:2]), layout.par = list(dist = "uniang")))
  })}
)))

# compare to ggnet2:
ggnet2 <- data.frame(t(replicate(100, system.time(print(
  ggnet2(network(protein$edges[,1:2]), size = 2, color = "magenta",
      mode = "random", layout.par = list(dist = "uniang"),
      edge.alpha = 0.05)
)))))

# compare to geomnet:
geomnet <- data.frame(t(replicate(100, system.time(print(
ggplot(data = protein$edges, aes(from_id = from, to_id = to)) +
  geom_net(alpha = 0.25, ealpha = 0.05, size = 2, colour = "magenta",
           ecolour = "grey70", linewidth = 0.5,
           layout = "random", layout.par = list(dist = "uniang")) +
  theme_net()
)))))

# compare to ggnetwork:
ggnetwork <- data.frame(t(replicate(100, system.time(print(
  ggplot(ggnetwork(protein$edges[, 1:2], layout = "random", dist = "uniang"),
       aes(x, y, xend = xend, yend = yend)) +
  geom_edges(color = "grey70", lwd = 0.5, alpha = 0.05) +
  geom_nodes(alpha = 0.25, color = "magenta", size = 2) +
  theme_blank()
)))))


network$type <- "network"
ggnet2$type <- "ggnet2"
geomnet$type <- "geomnet"
ggnetwork$type <- "ggnetwork"

timings <- rbind(network, ggnet2, geomnet, ggnetwork)
write.csv(timings, file="data/timings.csv", row.names=FALSE)
} else {
  timings <- read.csv("data/timings.csv")
}

timings$type <- factor(timings$type, levels = rev(c("ggnet2", "geomnet", "ggnetwork", "network")))
qplot(data=timings, type, elapsed, geom="boxplot", fill = type, alpha = I(0.6)) +
  scale_fill_brewer(palette = "Set2") + theme_bw() +
  xlab("Visualisation Approach") + ylab("System time elapsed (in seconds)") +
  ylim(c(0, 7.1)) + theme(legend.position = "none") + coord_flip()
@
\includegraphics[width=.5\textwidth]{figure/compare-1.pdf}
\caption{\label{fig:timings} Comparison of the times needed for calculating and rendering the protein interaction network in the three \pkg{ggplot2} approaches (top three) and the standard plotting routine  of the \pkg{network} package based on 100 evaluations each.  }
\end{figure}

\section{Summary}

\hh{XXX We need to come up with a discussion. Let's get started with with some bullet points:}
\begin{enumerate}
\item \hh{this is a personal comment, and we don't have to include it in the final summary: I think that this discussion between the three of us helped to make each one of the approaches better.
Partly, because we had some `Annie' thing going on (I can do anything you can do), e.g.\ the edge coloring in ggnet2 and ggnetwork really forced some discussion on how to best implement edge coloring in geomnet, which resulted  in the idea of the inside group/between group distinction using the \code{group} attribute. From one of your earlier comments, it sounded like that the whole geom idea of geomnet spurred the ggnetwork approach in the first place ... Other things that made it into each one of our approaches are the gaps for the arrows and the curves.
Another improvement that I see is that, trying to differentiate between the approaches helped to focus on what each approach is best at.
}

\fb{I agree with the general observation here. And yes, ggnetwork was inspired by reading the code from geomnet. I had never looked at the internals of ggplot2 before.}

\item \hh{Should we make recommendations as to what type of user would be happier with either one of the approaches?
I would think that the users of ggnet2 and ggnetwork are pretty well-versed with networks, and are looking at ggplot2 for  high-quality visualizations that also covers their other visualization needs. Data management and attribute handling is done through network operators on nodes and edges. These users might actually be attracted to ggplot2 because of the additional features open to them.

Out of these two approaches, ggnetwork is more flexible and allows, eg a re-ordering of layers to emphasize one over the other. On the flip side of the flexibility lies, of course, that the user has to specify every single part of the network.

The geomnet approach does not require any knowledge of networks from the user, so the audience would be people who are already familiar with ggplot2 and some of the other `Hadley'-verse, who find themselves dealing with data with a network structure. Data management skills are basic, some familiarity with the split-apply-combine paradigm, for example in form of plyr or dplyr, would be good to make full use of the features.

I would like to think that both approaches are valid and necessary.
}

\fb{I don't have many ideas about the userbase of each function. All I know is that I get emails from time to time about ggnet and ggnet2. Some are from complete beginners (just got one this morning), others are much more advanced (e.g. Pedro Jordano, who helped me understand bipartite graphs). My guess is that all of them stumbled upon the function by googling for "network + ggplot2".}
\item{ \hh{internal calculation of the network versus external. Each call to geomnet results in a re-calculation of the network and, unless a seed is set, in a new layout. Once the network is calculated, subsequent calls to ggnet2 and ggnetwork are computationally more efficient.}
\item \fb{This is not really a to-do, just an observation: the placement algorithms availabe through \pkg{igraph} seem both more divserse and more correct than those provided through \pkg{sna}. This is likely due to the factthat the first package is still under active development, while the second one is more or less dormant. An illustration of that is the Kamada-Kawai algorithm, which can take edge weights into account in the \pkg{igraph} implementation but not in the \pkg{sna} one (AFAICT). Consequently, if I had to learn network analysis in R all over again, I would choose to use \pkg{igraph} instead of \pkg{network} + \pkg{sna}.}
\hh{We definitely need to discuss edge weights in the discussion. I am not sure that I have the same take on packages - I would not assume that not being under active development is equivalent to `dormant'.  }
}
\end{enumerate}


\bibliography{tyner-briatte-hofmann}

\address{Samantha Tyner\\
  Department of Statistics and Statistical Laboratory\\
  Iowa State University\\
  United States\\}
\email{sctyner@mail.iastate.edu}

\address{Fran\c{c}ois Briatte\\
  European School of Political Sciences\\
  Catholic University of Lille\\
  France\\}
\email{francois.briatte@univ-catholille.fr}

\address{Heike Hofmann\\
  Department of Statistics and Statistical Laboratory\\
  Iowa State University\\
  United States\\}
\email{hofmann@mail.iastate.edu}
